#montecarlo.jl
include("lattice.jl")

@inline function monte_carlo_timestep!(lattice::Lattice, move::String, beta::Float64; verbose::Bool=false, k::Int64=1)
    # generates potential move's flip sites
    flips = generate_moves(lattice, move, k)

    # calculates energy difference of proposed move
    energy_difference = energy_change(lattice,flips)

    # MH logic on whether to accept the proposed move
    if energy_difference <= 0 || rand() < exp(-beta * energy_difference)
        # if move is accepted, flip the propose sites
        do_flips(lattice, flips)
        return 1
    else
        return 0
    end

end

function run_metropolis_algorithm(lattice::Lattice, beta::Float64, k::Int64, move::String = "single flip"; maximum_iterations::Int64=10000, verbose::Bool=false)
    # runs metropolis-hastings algorithm
    # for given move funciton, beta and k
    # predetermined iteration cutoff
    # cutoff is generated by studying autocorrelation function

    current_iteration = 0
    accepted_candidates = 0

    #iterate algorithm until cutoff
    while (current_iteration <= maximum_iterations)
 
        accepted_candidates_increase = monte_carlo_timestep!(lattice, move, beta; verbose=verbose, k=k)

        current_iteration += 1
        accepted_candidates += accepted_candidates_increase
        # calculate correlation function every lattice.N^2 iterations
        # ie 1 Monte-Carlo iteration
        #if use_correlation

        
    end

    
    

    return (current_iteration, accepted_candidates)
end

function generate_T_intervals(T_hot::Float64, T_cold::Float64, num_intervals::Int64)
    # generates a non-linearly spaced array of temperatures
    # we want a higher density of temperature at T_cold than T_hot
    # as we are interested in the low temperature regime
    if T_hot <= T_cold
        throw(ArgumentError("T_hot must be greater than T_cold"))
    elseif T_cold == 0.0
        throw(ArgumentError("T_cold must be greater than 0"))
    end
    return T_hot .* (T_cold / T_hot) .^ (range(0, 1, length=num_intervals))
end

function generate_tau_0_array(T_max::Float64, T_min::Float64, tau0_Tmax::Int64, tau0_Tmin::Int64, num_intervals::Int64)
    # generates an array of tau_0 values
    # tau_0 is our initial guess for the decorrelation time
    # we want tau_0(T) = A * exp(B/T)
    # we want tau_0(T_max) = tau0_Tmax
    # we want tau_0(T_min) = tau0_Tmin
    B = log(tau0_Tmin / tau0_Tmax) / (1 / T_min - 1 / T_max)
    A = tau0_Tmax / exp(B / T_max)
    return A .* exp.(B ./ generate_T_intervals(T_max, T_min, num_intervals))
end



function generate_autocorrelation(lattice::Lattice, beta_values::Vector{Float64}; k::Int64 = 1, move::String = "single flip", tau0_Tmax::Int64= 10, tau0_Tmin::Int64 = 10000, copies::Int64 = 1, tau_length::Int64 = 10)
    T_max = 1 / beta_values[1]
    T_min = 1 / beta_values[end]
    tau0_array = generate_tau_0_array(T_max, T_min, tau0_Tmax, tau0_Tmin, length(beta_values))
    MC_step = lattice.N^2
    data_runs = []
    for _ in 1:copies
        data = []
        for (i,beta) in enumerate(beta_values)
            println("beta =$beta")
            lattice.grid = random_configuration(lattice.N, 0.5)
            t = []
            C_t = []
            m_t = []
            eq_iteration = 0
            #run for tau0(T) MC timesteps to equilibriate before we can measure
            max_eq_iterations = tau0_array[i] * MC_step
            #max_eq_iterations = MC_step * 1000
            while eq_iteration < (max_eq_iterations)
                monte_carlo_timestep!(lattice, move, beta, k = k)
                eq_iteration += 1
            end

            m_0 = sum(lattice.grid)
            reference_lattice = copy(lattice.grid)

            measurement_MC_step = 0
            #max_measurement_steps = 10000
            while measurement_MC_step < tau_length * tau0_array[i]
            #while measurement_MC_step < max_measurement_steps

                
            
                m = sum(lattice.grid)
                C = m * m_0
                push!(t, measurement_MC_step)
                push!(C_t, C)
                push!(m_t, m)
                
                # do 1 monte carlo step,ie 1 iteration per site
                for _ in 1:MC_step
                    monte_carlo_timestep!(lattice, move, beta, k = k)
                end
                measurement_MC_step += 1
                
                
            end
            push!(data, [beta, [t, C_t, m_t, m_0]])
        end
        push!(data_runs, data)
    end
    autocorr_beta = []
    for j in 1:length(beta_values)
        all_C_t = [ data_runs[i][j][2][2] for i in 1:copies ]
        all_m_t = [ data_runs[i][j][2][3] for i in 1:copies ]
        all_m_0 = [ data_runs[i][j][2][4] for i in 1:copies ]
        
        n_points = length(all_C_t[1])
        t_vals = data_runs[1][j][2][1]
        C_t_mean = [ mean( [ all_C_t[i][k] for i in 1:copies ] ) for k in 1:n_points ] / (lattice.N^2)
        m_t_mean = [ mean( [ all_m_t[i][k] for i in 1:copies ] ) for k in 1:n_points ] / (lattice.N^2)
        m_0_mean = mean(all_m_0) / (lattice.N^2)
        
        
        autocorr = [ C_t_mean[k] - m_t_mean[k] * m_0_mean for k in 1:n_points ]
        push!(autocorr_beta, [beta_values[j], [autocorr, t_vals]])
    end

    
    
    
    return autocorr_beta
end

function generate_tau_quick(lattice::Lattice, beta_values::Vector{Float64}; k::Int64 = 1, move::String = "single flip" , tau0_Tmax::Int64= 10, tau0_Tmin::Int64 = 10000, copies::Int64 = 1, tau_length::Int64 = 10, save_file::Bool = false, filename::String = "autocorrelation.csv")
    autocorr_beta = generate_autocorrelation(lattice, beta_values, k = k, move = move, tau0_Tmax = tau0_Tmax, tau0_Tmin = tau0_Tmin, copies = copies, tau_length = tau_length)
   if save_file 
        open(filename, "w") do io
            for entry in autocorr_beta
                autocorr = entry[2][1]  # Extract the autocorrelation vector
                writedlm(io, [autocorr], ',')  # Write as a row
            end
        end
    end
    
    tau_values = []
    for (i, beta) in enumerate(beta_values)
        autocorr = autocorr_beta[i][2][1]
        t_vals = autocorr_beta[i][2][2]
        tau = t_vals[end]
        for (j,a) in enumerate(autocorr)
            if a < exp(-1)
                tau = t_vals[j]
                break
            end
        end
        push!(tau_values, tau)
    end
    return tau_values
end


function generate_autocorrelation2(lattice::Lattice, beta_values::Vector{Float64}; k::Int64 = 1, move::String = "single flip")
    # sum over sites on lattice only at the end
    measurement_steps = 100000
    equilib_steps =10000
    MC_step = lattice.N^2
    max_lag = 2000
    lag = [i for i in 0:max_lag]
    autocorr_beta = []

    for beta in beta_values
        println(beta)
        time = now()
        history = []

        for _ in 1:equilib_steps * MC_step
            monte_carlo_timestep!(lattice, move, beta, k = k)
        end

        #measure lattice evolution every MC step
        for _ in 1:measurement_steps
            measurement = energy(lattice)
            #measurement = sum(lattice.grid) / lattice.N^2
            push!(history, measurement)
            for _ in 1:MC_step/10
                monte_carlo_timestep!(lattice, move, beta, k = k)
            end
        end
        if beta == beta_values[1]
            println(history)
        end

        mag_avg = mean(history)
        mag_var= var(history)

        autocorr_history = []
        for tau in lag
            autocorr = 0
            for t0 in 1:(length(history) - tau)
                autocorr += (history[t0] - mag_avg) * (history[t0 + tau] - mag_avg)
            end
            autocorr = autocorr / ((length(history) - tau)*mag_var)
            push!(autocorr_history, autocorr)
        end
        push!(autocorr_beta, (beta, autocorr_history))
        println(now() - time)
    end
    return autocorr_beta
end

function generate_tau_quick2(lattice::Lattice, beta_values::Vector{Float64}, save_file::Bool = false, k::Int64 = 1, move::String = "single flip", filename::String = "autocorrelation.csv")
    autocorr_beta = generate_autocorrelation2(lattice, beta_values, k = k, move = move)
    if save_file
        open(filename, "w") do io
            for entry in autocorr_beta
                autocorr = entry[2]  # Extract the autocorrelation vector
                writedlm(io, [autocorr], ',')  # Write as a row
            end
        end
    end

    tau_values = []
    for (i, beta) in enumerate(beta_values)
        autocorr = autocorr_beta[i][2]
        tau = autocorr[end]
        for (j,a) in enumerate(autocorr)
            if a < exp(-1)
                tau = j
                break
            end
        end
        push!(tau_values, tau)
    end
    return tau_values
end


function prepare_lattice!(lattice::Lattice,k::Int64 = 1; MC_steps::Int64 = 10)
    #prepares lattice in minimal energy state (all aligned)
    #this is an accessible state if system is ergodic
    #then runs metropolis algorithm for beta = 0
    #for 100 Monte-Carlo steps - probably overkill?
    #equivalent to infinite temperature, all moves are accepted
    lattice.grid = solved_configuration(lattice.N)
    run_metropolis_algorithm(lattice, 0.0, k, maximum_iterations = MC_steps * lattice.N^2)
end

function generate_energies(lattice::Lattice, beta_values::Vector{Float64}, k::Int64, tau_values::Vector{Int64}, move::String = "single flip", measurement_tau_separation::Int64 = 5)
    #n_correlation = generate_decorrelation_n(lattice, beta_values; k=k, move="single flip")
    energies = Float64[]
    # beta values array of decreasing temperatures
    # as we cool from hot to cold
    # so increasing beta
    
    # for each beta value
    # run metropolis algorithm for n_correlation[i] iterations
    # our decorrelation cutoff determined by "generate_decorrelation_n"
    # calculate the total energy of the lattice and store in array

    #prepare lattice in hot state
    prepare_lattice!(lattice, 1)
    for (i,beta) in enumerate(beta_values)
        #println(beta)
        run_metropolis_algorithm(lattice, beta, k, move, maximum_iterations = tau_values[i] * measurement_tau_separation)
        E = energy(lattice)
        push!(energies, E)
    end
    return energies
end
    
function generate_saddles_run(lattice::Lattice, beta_values::Vector{Float64}, k::Int64, tau_values::Vector{Int64}, measurement_tau_separation::Int64 = 5, move::String = "single flip")
    # prepare lattice in a 'hot state'
    # for each beta
    # cool to beta using single spin flips
    # once cooled, explore moves, calculate energy of system

    prepare_lattice!(lattice)
    # we could also use the decorrelation_n here
    # to determine how many iterations it takes to cool?
    # make sure we're starting hot (low beta)
    saddle_values = Int64[]
    energy_values = Float64[]

    for (i,beta) in enumerate(beta_values)
        run_metropolis_algorithm(lattice, beta, k, "single flip", maximum_iterations = tau_values[i]*measurement_tau_separation)
        push!(energy_values, energy(lattice))
        saddles = explore_moves(lattice, k, move)
        push!(saddle_values,saddles)
    end
    return (saddle_values, energy_values, beta_values)
end

function generate_saddles(lattice::Lattice, beta_values::Vector{Float64}, k::Int64, move::String,  m::Int64 = 1, cooling_time::Int64 = 10000)
    # generate multiple runs of saddle points
    # and return the average saddle point
    # and energy values
    saddle_values = []
    energy_values = []
    output_beta_vals = []
    critical_energy_values = []
    critical_beta_values = []

   # to use threads?
    for j in 1:m
         #add noise to beta values
        noisy_beta_values = beta_values .+ randn(length(beta_values)) .* 0.1 .* beta_values
        #println(beta_values)
        #println(noisy_beta_values)
        (saddles, energies, betas) = generate_saddles_run(lattice, noisy_beta_values, k, move, cooling_time)
        push!(saddle_values, saddles)
        push!(energy_values, energies)
        push!(output_beta_vals, betas)
        println("run = $j")
        #identifying tempetature and beta at which saddle index vanishes upon cooling.
        critical_energy = -2.0
        critical_beta = 0.0
        for (i,s) in enumerate(saddles)
            if s == 0
                critical_energy = energies[i]
                critical_beta = betas[i]
                break
            end
        end
        push!(critical_energy_values, critical_energy)
        push!(critical_beta_values, critical_beta)
        

    

    
    end
    return (saddle_values, energy_values, output_beta_vals, critical_energy_values, critical_beta_values, k)
end